{
  "posts": [
    {
      "content": "## 多级菜单\r\n\r\n在平时的项目中会经常碰到这样一种布局，暂且称之为多级菜单吧\r\n\r\n![](https://xboxyan.codelabo.cn/post-images/1558439549223.png)\r\n\r\n（截图来自于[ant-design](https://ant.design/components/menu-cn/)）\r\n\r\n这类布局也很容易，大概就是这样`ul`和`li`嵌套，如下\r\n\r\n```html\r\n<ul class=\"parent\">\r\n    <li>\r\n        <div>Navigation01</div>\r\n        <ul>\r\n            <li><div>Option01</div></li>\r\n            <li><div>Option02</div></li>\r\n            <li>\r\n                <div>Submenu</div>\r\n                <ul>\r\n                    <li><div>Option03</div></li>\r\n                    <li><div>Option04</div></li>\r\n                </ul>\r\n            </li>\r\n        </ul>\r\n    </li>\r\n    <li><div>Navigation02</div></li>\r\n</ul>\r\n```\r\n\r\n于是就得到下面一个很原始的样式。\r\n\r\n![](https://xboxyan.codelabo.cn/post-images/1558440703375.png)\r\n\r\n再经过简单的修饰就可以达到上面的效果了。\r\n\r\n当然，这个很容易，一般情况下我们是通过设置内边距来完成的，比如默认为\r\n\r\n```css\r\nul{\r\n\tpadding-left:40px;\r\n}\r\n```\r\n\r\n然后每一层级跟随父级逐步累积，然后就实现了，层级越深，距离左边的缩进越多的效果。\r\n\r\n## 多级菜单选中范围\r\n\r\n通过上面的布局和样式，很显然每一项的选择范围都是逐步缩进的，\r\n\r\n![](https://xboxyan.codelabo.cn/post-images/1558441705019.png)\r\n\r\n但是，可能设计师觉得不好看，往往会设计成通栏的形式，比如像上面[ant-design](https://ant.design/components/menu-cn/)的设计\r\n\r\n![](https://xboxyan.codelabo.cn/post-images/1558441856625.png)\r\n\r\n那么，该如何处理呢？\r\n\r\n## 通栏的处理方式\r\n\r\n首先，一个很自然的思路就是去除`ul`的`padding`，改为每一个子项分别指定`padding`\r\n\r\n```css\r\nul.parent{\r\n\tpadding: 0;\r\n}\r\n```\r\n\r\n然后将内边距直接写在`html`上，如下\r\n\r\n```html\r\n<ul  class=\"parent\">\r\n    <li>\r\n        <div style=\"padding-left:40px\">Navigation01</div>\r\n        <ul>\r\n            <li><div style=\"padding-left:80px\">Option01</div></li>\r\n            <li><div style=\"padding-left:80px\">Option02</div></li>\r\n            <li>\r\n                <div style=\"padding-left:80px\">Submenu</div>\r\n                <ul>\r\n                    <li><div style=\"padding-left:120px\">Option03</div></li>\r\n                    <li><div style=\"padding-left:120px\">Option04</div></li>\r\n                </ul>\r\n            </li>\r\n        </ul>\r\n    </li>\r\n    <li><div style=\"padding-left:40px\">Navigation02</div></li>\r\n</ul>\r\n```\r\n\r\n如果菜单层级较多，我们通常使用js来辅助生成，注意每一次循环来指定不同的内边距就可以了\r\n\r\n![](https://xboxyan.codelabo.cn/post-images/1558442384266.png)\r\n\r\n[ant-design](https://ant.design/components/menu-cn/)也是采取这种方式，可以自行打开控制台去查看。\r\n\r\n记得刚入前端的时候就是采取的这种方式，效果实现就好。\r\n\r\n不过，在现在看来，在`html`中使用内联样式始终不雅，而且数量较多时还需要和`js`扯上关系，能否优化一下呢\r\n\r\n下面列举两种css方式\r\n\r\n### 1.子选择器\r\n\r\n我们可以在上面的基础上，分别控制每一级的内边距，这里我们可以使用子选择器`>`\r\n\r\n```css\r\nul.parent>li>div{/**第一级**/\r\n    padding-left: 40px;\r\n}\r\nul.parent>li>ul>li>div{/**第二级**/\r\n    padding-left: 80px;\r\n}\r\nul.parent>li>ul>li>ul>li>div{/**第三级**/\r\n    padding-left: 120px;\r\n}\r\n/** ... **/\r\n```\r\n\r\n通常，在层级不是特别多的情况下，我们可以一一罗列出来，只需用选择器`ul>li`叠加即可，是不是比`style`方便维护了很多呢？\r\n\r\n### 2.absolute半依赖定位\r\n\r\n未完待续...\r\n\r\n\r\n\r\n",
      "data": {
        "title": "CSS 关于多级菜单的内边距的处理方式",
        "date": "2019-05-21 19:26:54",
        "tags": [
          "css"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "css-tree-padding"
    },
    {
      "content": "CSS3 中有很多表示元素序号的选择器，有以下几种\r\n\r\n`:first-child`、`:first-of-type`、`:last-of-type`、`:only-of-type`、`:only-child`、`:nth-child(n)`、`:nth-last-child(n)`、`:nth-of-type(n)`、`:nth-last-of-type(n)`、`:last-child`\r\n\r\n<!-- more -->\r\n\r\n初学者可能会比较容易混淆，这里我可以分一下类\r\n\r\n|***-of-type**|***-child**|\r\n|---|---|\r\n|`:first-of-type`|`:first-child`|\r\n|`:last-of-type`|`:last-child`|\r\n|`:nth-of-type(n)`|`:nth-child(n)`|\r\n|`:nth-last-of-type(n)`|`:nth-last-child(n)`|\r\n|`:only-of-type`|`:only-child`|\r\n\r\n可以看出完全是一一对应，相信CSS开发者都对这些选择器的功能有个大致印象，比如`first-*`表示第一个，`nth-*`表示第几个，`nth-last-*`表示倒数第几个...\r\n\r\n## *-of-type 和 *-child\r\n\r\n那么，***-of-type**和***-child** 到底有什么区别呢？\r\n\r\n从字面上来看，其实就是`type`和`child`的区别，也就是说\r\n\r\n**`type`表示类型，一类元素，比如都是`p`元素或者`div`元素**\r\n\r\n**`child`表示子元素，没有什么限制**\r\n\r\n这样描述可能不直观，下面列举一个实例来说明\r\n\r\n## :first-of-type 和 :first-child\r\n\r\n```html\r\n<div>\r\n\t<h1 class=\"h1\">标题1</h1>\r\n\t<h1  class=\"h2\">标题2</h1>\r\n\t<p class=\"p1\">段落1</p>\r\n\t<p class=\"p2\">段落2</p>\r\n</div>\r\n```\r\n\r\n这里写了一个交互实例，可以随时比较各个选择器的结果\r\n\r\n<p class=\"codepen\" data-height=\"622\" data-theme-id=\"34022\" data-default-tab=\"html,result\" data-user=\"xboxyan\" data-slug-hash=\"dEvxPr\" style=\"height: 622px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;\" data-pen-title=\"css3 选择器:first-of-type 和:first-child\">\r\n  <span>See the Pen <a href=\"https://codepen.io/xboxyan/pen/dEvxPr/\">\r\n  css3 选择器:first-of-type 和:first-child</a> by XboxYan (<a href=\"https://codepen.io/xboxyan\">@xboxyan</a>)\r\n  on <a href=\"https://codepen.io\">CodePen</a>.</span>\r\n</p>\r\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\r\n\r\n下面是各种选择的结果\r\n\r\n1. `div :first-of-type`可以选中 *标题1* 和 *段落1*\r\n\r\n1. `div h1:first-of-type`可以选中 *标题1*\r\n\r\n1. `div p:first-of-type`可以选中 *段落1*\r\n\r\n1. `div .h1:first-of-type` 可以选中 *标题1*\r\n\r\n1. `div .h2:first-of-type` 未匹配\r\n\r\n1. `div :first-child` 可以选中 *标题1*\r\n\r\n1. `div p:first-child` 未匹配\r\n\r\n1. `div h1:first-child`  `可以选中 *标题1*\r\n\r\n1. `div .h1:first-child`  `可以选中 *标题1*\r\n\r\n1. `div .h2:first-child`  未匹配\r\n\r\n这里有个容易出错的地方，比如`div .h2:first-of-type`，很多人以为会选择到第一个class为`.h2`的元素，其实不是的，这里可以这么来理解：\r\n\r\n**首先，`div .h2:first-of-type`会查找`.h2`类名所对应的元素，这里是`h1`元素，所以`:first-of-type`会匹配第一个`h1`元素，也就是说，这里的class类名只是找到对应元素类型的作用。接下来结合起来看，第一个`h1`的元素的class并不是`.h2`，所以就无法匹配到。**\r\n\r\n**同样，`div p:first-child`也是同样的道理，`:first-child`会首先找第一个元素，然后发现第一个元素并不是`p`元素，所以也匹配不到**\r\n\r\n由此可见，我们在用`:first-of-type`时，其实只需要带上标签名就可以了，比如`div p:first-of-type`，根本不需要带上类名，如果不加标签名，那么会选择每种类型元素的第一个（示例1）\r\n\r\n而用`:first-child`时，根本不需要带上任何标识，因为始终会匹配到第一个元素，否则加上别的条件就匹配不到了（当然特殊需求除外）。\r\n\r\n那么，如果想实现上述第一个`.h2`该如何实现呢，很可惜，这些方式不能满足，你只能通过其他方式来完成，比如`~`选择器\r\n\r\n```html\r\n<div>\r\n\t<h1 class=\"h1\">标题1</h1>\r\n\t<h1  class=\"h2\">标题2</h1>\r\n\t<h1  class=\"h2\">标题2</h1>\r\n\t<p class=\"p1\">段落1</p>\r\n\t<p class=\"p2\">段落2</p>\r\n</div>\r\n```\r\n\r\n这种情况下，如何选择到第一个`h1.h2`呢?\r\n\r\n---\r\n\r\n思考一下...\r\n\r\n---\r\n\r\n直接给答案\r\n\r\n```css\r\n.h2{ \r\n  outline:2px solid red;\r\n}\r\n.h2~.h2{\r\n  outline:0;\r\n}\r\n```\r\n\r\n意思就是先选中所有的`.h2`，然后排除掉兄弟节点的其他`.h2`\r\n\r\n<p class=\"codepen\" data-height=\"379\" data-theme-id=\"34022\" data-default-tab=\"html,result\" data-user=\"xboxyan\" data-slug-hash=\"GamPQJ\" style=\"height: 379px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;\" data-pen-title=\"css 选择器\">\r\n  <span>See the Pen <a href=\"https://codepen.io/xboxyan/pen/GamPQJ/\">\r\n  css 选择器</a> by XboxYan (<a href=\"https://codepen.io/xboxyan\">@xboxyan</a>)\r\n  on <a href=\"https://codepen.io\">CodePen</a>.</span>\r\n</p>\r\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\r\n\r\n理解上面几种选择器的规则，那么下面几类都是一样的了\r\n\r\n## :last-of-type和:last-child\r\n\r\n这与`:first-of-type` 和 `:first-child`用法完全一致，表示最后一个，这里不做多讲解\r\n\r\n有一点注意的是，`:first-child`是CSS2的范畴，意味着在IE8也能使用，而`last-child`是CSS3的规范，在同时都能满足需求时，如果需要更好的兼容性，建议使用`:first-child`。\r\n\r\n一个很常见的场景，比如一个列表，列表的每一项都一条分割线，我们可以使用`border`来模拟，那么是上边框还是下边框呢，都可以满足需求\r\n\r\n```css\r\nli{\r\n\t***\r\n\tborder-top:1px solid;\r\n}\r\nli:first-child{\r\n\tborder-top:0;\r\n}\r\n```\r\n\r\n显然，使用上边框结合`:first-child`兼容性更好。\r\n\r\n## :nth-of-type(n)和:nth-child(n)\r\n\r\n这类选择器主要是选择第n个元素，跟元素序号有关，注意这里的起始序号为1（和js略微不同）\r\n\r\n`n`可以是数字、关键词或公式。\r\n\r\n比如说`p:nth-of-type(1)`表示每个父级下第一个`p`元素，等同于`p:first-of-type`\r\n\r\n关键词可以选择`odd`和`even`，分别表示奇数和偶数，常见场景就是表格\r\n\r\n```css\r\ntr:nth-child(odd){\r\n\tbackground:#ff0000;\r\n}\r\ntr:nth-child(even){\r\n\tbackground:#0000ff;\r\n}\r\n```\r\n\r\n`n`还可以使用公式`an + b`，常见场景是选择周期性的元素\r\n\r\n```css\r\np:nth-child(3n+0){\r\n\tbackground:#ff0000;\r\n}\r\n```\r\n\r\n## `:nth-last-of-type(n)`和`:nth-last-child(n)`\r\n\r\n与`:nth-of-type(n)`和`:nth-child(n)`基本一致，只是从后面开始计数\r\n\r\n结合`:nth-last-child(n)`与`:first-child`可以匹配出列表中不同元素数量的不同样式\r\n\r\n比如`:nth-last-child(3):first-child`表示从后往前数选中第3个子元素，同时也是第一个元素，那么就可以判断改列表中共有3个元素，结合兄弟选择器`+`和`~`可以对不同数量的子元素分别指定样式\r\n\r\n```css\r\nli:only-child {\r\n  height: 100%;\r\n}\r\n/* 2个 */\r\nli:first-child:nth-last-child(2),\r\nli:first-child:nth-last-child(2) + li {\r\n  width: 50%; height: 50%;\r\n}\r\nli:first-child:nth-last-child(2) + li {\r\n  margin-left: auto;\r\n}\r\n/* 3个 */\r\nli:first-child:nth-last-child(3),\r\nli:first-child:nth-last-child(3) ~ li {\r\n  width: 50%; height: 50%;\r\n}\r\n```\r\n\r\n大家可以看看[张鑫旭的这篇文章](https://www.zhangxinxu.com/wordpress/2019/03/nth-last-child-css-layout/)，算是一个比较实用的场景\r\n\r\n## `:only-of-type 和 :only-child`\r\n\r\n这个是表示当只有一个元素，或者同类型元素只有一个的时候使用\r\n\r\n```html\r\n<div>\r\n\t<h1 class=\"h1\">标题1</h1>\r\n\t<h1  class=\"h2\">标题2</h1>\r\n\t<h1  class=\"h2\">标题2</h1>\r\n\t<p class=\"p1\">段落1</p>\r\n\t<span>文本</span>\r\n</div>\r\n```\r\n\r\n* `div :only-of-type`可以选中 *标题2* *文本*\r\n* `div p:only-of-type`可以选中 *标题2*\r\n* `div :only-child` 匹配不到任何元素\r\n\r\n## 小节\r\n\r\n其实大家只要注意 **`*-of-type` 是选择相同类型的元素 、` *-child`是选择子节点 ** 就好了，\r\n\r\n相信未来可能会出现更全面的选择器，比如`nth-of-class`（根据class来选择），`nth-of-*` （根据任意选择器来选择），还是期待一下吧~\r\n\r\n\r\n\r\n",
      "data": {
        "title": "CSS3 中关于 *-of-type 和 *-child的差异性及适用场景",
        "date": "2019-05-16 18:58:39",
        "tags": [
          "css3"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/css3-of-type-child.jpg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "CSS3 中有很多表示元素序号的选择器，有以下几种\r\n\r\n`:first-child`、`:first-of-type`、`:last-of-type`、`:only-of-type`、`:only-child`、`:nth-child(n)`、`:nth-last-child(n)`、`:nth-of-type(n)`、`:nth-last-of-type(n)`、`:last-child`\r",
      "fileName": "css3-of-type-child"
    },
    {
      "content": "css3中实现动画一般有两种方式，一个是`transition`过渡，一个是`animation`动画。最主要区别就是`transition`需要条件触发，通常会用`hover`来触发，而`animation`则更灵活，可以自动播放，也可以通过条件触发。\r\n\r\n<!-- more -->\r\n\r\n那么，如何实现一个元素出现动画呢？\r\n\r\n如果是`transition`，可以很轻松的实现这一效果，例如\r\n\r\n```css\r\n.box{\r\n  visibility:hidden;\r\n  opacity:0;\r\n  transform:translateY(100px);\r\n  transition:.3s;\r\n}\r\n.show{\r\n  visibility:visible;\r\n  opacity:1;\r\n  transform:translateY(0);\r\n}\r\n```\r\n\r\n这样就实现了一个“从下至上，透明度从0至1”的出现动画，很常用不是吗。\r\n\r\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"show-transition\" src=\"//codepen.io/xboxyan/embed/LveVoO/?height=300&theme-id=34022&default-tab=css,result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\r\n  See the Pen <a href='https://codepen.io/xboxyan/pen/LveVoO/'>show-transition</a> by XboxYan\r\n  (<a href='https://codepen.io/xboxyan'>@xboxyan</a>) on <a href='https://codepen.io'>CodePen</a>.\r\n</iframe>\r\n\r\n当然，我们也可以用`animation`来实现，\r\n\r\n```css\r\n.box{\r\n  visibility:hidden;\r\n  opacity:0;\r\n  transform:translateY(100px);\r\n  transition:.3s;\r\n}\r\n.show{\r\n  animation:show .5s forwards;\r\n}\r\n\r\n.hide{\r\n  visibility:visible;\r\n  opacity: 1;\r\n  transform: translateY(0);\r\n  animation:hide .5s forwards;\r\n}\r\n@keyframes show{\r\n  to {\r\n    visibility:visible;\r\n    opacity: 1;\r\n    transform: translateY(0)\r\n  }\r\n}\r\n@keyframes hide{\r\n  to {\r\n    visibility:hidden;\r\n    opacity: 0;\r\n    transform: translateY(100px)\r\n  }\r\n}\r\n```\r\n\r\n我的天，居然要写这么多，才能实现和上面一样的效果，没办法，出现和消失是两组不同的动画，所以需要定义两个动画。\r\n\r\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"show-animation\" src=\"//codepen.io/xboxyan/embed/KYZdKp/?height=300&theme-id=34022&default-tab=css,result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\r\n  See the Pen <a href='https://codepen.io/xboxyan/pen/KYZdKp/'>show-animation</a> by XboxYan\r\n  (<a href='https://codepen.io/xboxyan'>@xboxyan</a>) on <a href='https://codepen.io'>CodePen</a>.\r\n</iframe>\r\n\r\n## 元素出现动画\r\n\r\n上面简单的介绍了动画的两种实现方法。严格来讲，`transition`只是过渡，只是切换样式过程中有动画的效果，而`animation`才是真正做动画的。当然也需要根据自己的实际需求来选择。\r\n\r\n下面来看这样一个需求：\r\n\r\n通常页面上要全局显示一个消息提示，类似于`toast`效果。这是我通常的做法\r\n\r\n```js\r\nfunction showMessage(txt){\r\n    this.timer && clearTimeout(this.timer);\r\n    var oDiv = document.getElementById('messageInfo');\r\n    if(!oDiv){\r\n      oDiv = document.createElement('div');\r\n      oDiv.className = 'messageInfo';\r\n      oDiv.id = 'messageInfo';\r\n      document.body.appendChild(oDiv);\r\n    }\r\n    oDiv.innerHTML = '<span>'+txt+'</span>';\r\n    oDiv.classList.add('show');\r\n    this.timer = setTimeout(function(){\r\n      oDiv.classList.remove('show');\r\n    },2000)\r\n}\r\n```\r\n\r\n原理就是，向页面添加一个`div#messageInfo`容器，然后添加类名`.show`让元素出现，2s后自动移除`.show`实现隐藏，效果如下\r\n\r\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"toast\" src=\"//codepen.io/xboxyan/embed/axEddQ/?height=300&theme-id=34022&default-tab=js,result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\r\n  See the Pen <a href='https://codepen.io/xboxyan/pen/axEddQ/'>toast</a> by XboxYan\r\n  (<a href='https://codepen.io/xboxyan'>@xboxyan</a>) on <a href='https://codepen.io'>CodePen</a>.\r\n</iframe>\r\n\r\n可以很明显的看到一个效果就是，第一次出现的时候是没有动画的，以后就正常了。可能平时项目中，这一点小瑕疵也没什么影响，毕竟很大一部分人连动画都不给啊，直接就是`display:none`和`display:block`，可以说是提不上体验了。\r\n\r\n那么，为什么会出现这种现象呢？\r\n\r\n首先明白一点，`transition`是不会自动触发的，上面是通过添加和移除类名来实现过渡效果的。但是在第一次元素刚刚创建的时候，此时页面改元素还未加载完成，这个时候立即添加类名，其实是可以等同于是一起创建的，没有形成过渡效果。解决这个问题很简单，就是稍微延时一下\r\n\r\n```js\r\n//...\r\nsetTimeout(function(){\r\n   oDiv.classList.add('show');\r\n},50)\r\n//...\r\n```\r\n\r\n这样就基本上解决了这个问题，如下\r\n\r\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"toast-fix\" src=\"//codepen.io/xboxyan/embed/LveNYN/?height=300&theme-id=34022&default-tab=js,result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\r\n  See the Pen <a href='https://codepen.io/xboxyan/pen/LveNYN/'>toast-fix</a> by XboxYan\r\n  (<a href='https://codepen.io/xboxyan'>@xboxyan</a>) on <a href='https://codepen.io'>CodePen</a>.\r\n</iframe>\r\n\r\n但是，理论上这里的延迟越小越好，我测试了一下，大概和浏览器的性能有关吧，用定时器的目的也仅仅是等待元素加载完成，而dom也没有原生监听加载完成事件，所以只能用定时器估一个大概的值。\r\n\r\n但是，这仍然是一个瑕疵，从代码结构上来讲，这也是无法忍受的。那么，还有没有更好的方法呢？答案就是`animation`\r\n\r\n## Animation\r\n\r\n虽然从开头的例子来看，`animation`的写法又臭又长，但是也正体现出它的功能强大，其中之一就是自动播放动画\r\n\r\n那么，把上面的`toast`改造一下\r\n\r\n```css\r\n.messageInfo{ \r\n    /**...**/\r\n    animation:show .5s forwards;\r\n}\r\n.hide{\r\n  visibility:visible;\r\n  opacity: 1;\r\n  transform: translateY(0);\r\n  animation:hide .5s forwards;\r\n}\r\n@keyframes show{\r\n  to {\r\n    visibility:visible;\r\n    opacity: 1;\r\n    transform: translateY(0)\r\n  }\r\n}\r\n@keyframes hide{\r\n  to {\r\n    visibility:hidden;\r\n    opacity: 0;\r\n    transform: translateY(-100%)\r\n  }\r\n}\r\n```\r\n\r\njs基本和之前一致\r\n\r\n```js\r\nfunction showMessage(txt){\r\n    this.timer && clearTimeout(this.timer);\r\n    var oDiv = document.getElementById('messageInfo');\r\n    if(!oDiv){\r\n      oDiv = document.createElement('div');\r\n      oDiv.className = 'messageInfo';\r\n      oDiv.id = 'messageInfo';\r\n      document.body.appendChild(oDiv);\r\n    }\r\n    oDiv.innerHTML = '<span>'+txt+'</span>';\r\n    oDiv.classList.remove('hide');//默认是显示\r\n    this.timer = \r\n      setTimeout(function(){\r\n      oDiv.classList.add('hide');//2s后隐藏\r\n    },2000)\r\n}\r\n```\r\n\r\n效果如下\r\n\r\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"toast-animation\" src=\"//codepen.io/xboxyan/embed/yrpOPm/?height=300&theme-id=34022&default-tab=css,result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\r\n  See the Pen <a href='https://codepen.io/xboxyan/pen/yrpOPm/'>toast-animation</a> by XboxYan\r\n  (<a href='https://codepen.io/xboxyan'>@xboxyan</a>) on <a href='https://codepen.io'>CodePen</a>.\r\n</iframe>\r\n\r\n可以说非常完美了。\r\n\r\n## 其他应用场景\r\n\r\n元素添加动画\r\n\r\n通常在添加表单或者上传图片时，如果需要让新添加的元素产生一个动画效果，那么可以用到`animation`\r\n\r\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"css 元素出现动画\" src=\"//codepen.io/xboxyan/embed/axLPgN/?height=300&theme-id=34022&default-tab=css,result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\r\n  See the Pen <a href='https://codepen.io/xboxyan/pen/axLPgN/'>css 元素出现动画</a> by XboxYan\r\n  (<a href='https://codepen.io/xboxyan'>@xboxyan</a>) on <a href='https://codepen.io'>CodePen</a>.\r\n</iframe>\r\n\r\n当然，还可以做到分页加载动画，需要给每个元素添加一个延时`animation-delay`即可\r\n\r\n```css\r\n/*animation-delay*/\r\n.list li:not(.hide):nth-child(5n + 1) {\r\n    animation-delay: .3s;\r\n}\r\n.list li:not(.hide):nth-child(5n + 2) {\r\n    animation-delay: .6s;\r\n}\r\n.list li:not(.hide):nth-child(5n + 3) {\r\n    animation-delay: .9s;\r\n}\r\n.list li:not(.hide):nth-child(5n + 4) {\r\n    animation-delay: 1.2s;\r\n}\r\n.list li:not(.hide):nth-child(5n + 5) {\r\n    animation-delay: 1.5s;\r\n}\r\n```\r\n\r\n效果如下，元素会依次登场，预览窗口比较小，建议在[原链接](https://codepen.io/xboxyan/pen/dLVwLv)查看\r\n\r\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"css批量出现动画\" src=\"//codepen.io/xboxyan/embed/dLVwLv/?height=300&theme-id=34022&default-tab=css,result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\r\n  See the Pen <a href='https://codepen.io/xboxyan/pen/dLVwLv/'>css批量出现动画</a> by XboxYan\r\n  (<a href='https://codepen.io/xboxyan'>@xboxyan</a>) on <a href='https://codepen.io'>CodePen</a>.\r\n</iframe>\r\n\r\n然后，还可以实现九宫格动画，让元素在出现的时候从左上方依次向右下方扩散，同样是用到了`animation-delay`\r\n\r\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"css九宫格出现动画\" src=\"//codepen.io/xboxyan/embed/zXEyLY/?height=300&theme-id=34022&default-tab=css,result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\r\n  See the Pen <a href='https://codepen.io/xboxyan/pen/zXEyLY/'>css九宫格出现动画</a> by XboxYan\r\n  (<a href='https://codepen.io/xboxyan'>@xboxyan</a>) on <a href='https://codepen.io'>CodePen</a>.\r\n</iframe>\r\n\r\n很酷炫不是吗，无需用到js，也无需用到其它框架，纯天然，支持的浏览器体验更上一层楼，不支持的浏览器也无伤大雅\r\n\r\n## 小节\r\n\r\n总体来说，`animation`远比`transition`要强大的多，当然在实际使用中，如果有交互，如鼠标移入，首先看`transition`能否实现，其次才是`animation`，如果像这一类元素出现（生成）动画，那么就需要使用到`animation`了。\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "CSS3 元素出现动画实例",
        "date": "2019-04-16 21:15:05",
        "tags": [
          "css3"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/css3-appear-animation.jpg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "css3中实现动画一般有两种方式，一个是`transition`过渡，一个是`animation`动画。最主要区别就是`transition`需要条件触发，通常会用`hover`来触发，而`animation`则更灵活，可以自动播放，也可以通过条件触发。\r",
      "fileName": "css3-appear-animation"
    },
    {
      "content": "## 概要\r\n\r\n这是一个半自动化的键盘访问解决方案，主要适用于需要完全键盘操作场景，比如大屏展示，电视，游戏菜单等，大大简化按键操作的逻辑。\r\n\r\n焦点使用虚拟焦点，也就是通过添加`.focus`等class实现，而不是原生自带的`:focus`，更利于定制化需求。\r\n\r\n基于`HTML`页面。\r\n\r\n> 比较冷门，键盘交互方向，不感兴趣的可以跳过。\r\n\r\n[项目地址](https://github.com/XboxYan/auto-keyboard)\r\n\r\n <!-- more -->\r\n\r\n## 特点\r\n\r\n模块化编程方式\r\n\r\n统一的按键处理\r\n\r\n统一的滚动动画\r\n\r\n[马上体验](https://web.codelabo.cn/auto-keyboard/)\r\n\r\n## 快速入门\r\n\r\n由于实际场景复杂多样，过于全反而会让业务代码更繁杂，不可维护。\r\n\r\n该功能插件仅针对于局部实现自动化操作，整体页面布局仍需开发者手动协调。\r\n\r\n具体是指开发者需要手动讲页面分为几块逻辑区域，比如下方的键盘区和搜索列表区。\r\n\r\n然后对每块区域分别调用`new View()`，每一块区域的逻辑互不干扰，可独立开发。\r\n\r\n```html\r\n<link href=\"./css/view.css\" type=\"text/css\" rel=\"stylesheet\">\r\n<div class=\"search_keyborad\" id=\"search\">\r\n    <a data-key=\"A\">A</a>\r\n    <a data-key=\"B\">B</a>\r\n    <a data-key=\"B\">C</a>\r\n    ...\r\n</div>\r\n<ul class=\"search_list\" id=\"list\">\r\n    <li class=\"search_item\">\r\n        <img src=\"\" >\r\n        <h3>11人类DNA密码破译</h3>\r\n    </li>\r\n    <li class=\"search_item\">\r\n        <img src=\"\" >\r\n        <h3>22人类DNA密码破译</h3>\r\n    </li>\r\n    ...\r\n</ul>\r\n<script type=\"text/javascript\" src=\"./js/smoothscroll.min.js\"></script>\r\n<script type=\"text/javascript\" src=\"./js/view.js\"></script>\r\n```\r\n\r\n```js\r\nvar S = $('search');\t\r\nvar L = $('list');\r\nvar V = new View(S);\r\nvar Vl = new View(L);\r\nV.init(S.getElementsByTagName('a'));\r\nVl.init(L.getElementsByTagName('li'));\r\nV.onfocus();\r\n```\r\n\r\n这样，每块区域的按键都已经自动适配了。\r\n\r\n然后针对每块区域的关联适当写一些逻辑即可。\r\n\r\n## 概念\r\n\r\n**区域** 指一块包含可获焦同类型同功能一类元素的集合，通过 `new View(container)`创建。\r\n\r\n**元素** 指区域里面每一个可以获焦的节点。\r\n\r\n## API\r\n\r\n通过`new View(#container)`适配的区域，可获焦元素可以是常见的`n*m`分布，也可以是绝对定位的任意布局。\r\n\r\n通过`V.init(children)`来初始化可获焦子元素，传入`nodeList`即可，与页面层级无关。\r\n\r\n### new View(container)\r\n\r\n核心方法。创建一个区域，传入参数为页面的一个容器。\r\n\r\n```js\r\nvar con = document.getElemetById('con');\r\nvar V = new View(con);\r\n```\r\n\r\n如果不传`container`，可创建一个虚拟的区域，你可以进入该区域进行其他操作，比如悬浮窗，视频播放等等。\r\n\r\n该方法通常只需加载一次。\r\n\r\n### V.init(nodeList)\r\n\r\n初始化，传入参数为需要获焦的子元素，通常使用`getElementsByTagName`来一次性传入多个。\r\n\r\n也可以通过数组形式传入特定的子元素，如下。\r\n\r\n```js\r\nvar child = [ nodeA,nodeB,nodeC ];\r\nV.init(child)\r\n```\r\n\r\n目的是能够完全控制子元素，因为有些情况下子元素可能不在同一层级。比如下方的`a`元素\r\n\r\n```html\r\n<div id=\"con\">\r\n    <a></a>\r\n    <div>\r\n        <span></span>\r\n        <a></a>\r\n        <a></a>\r\n    </div>\r\n    <a></a>\r\n</div>\r\n```\r\n\r\n该方法需要等待页面加载完全后使用（需要获取元素的位置关系），也就是说当动态加载网络数据时，需等待只元素加入容器之后调用\r\n\r\n```js\r\nV.init(S.getElementsByTagName('a'));\r\n\r\n//动态数据\r\najax({\r\n    url:'XXX',\r\n    sunccess:function(data){\r\n        var html = '';\r\n        for(var i=0;i<data.length;i++){\r\n            html+='<a>'+data[i]+'</a>';\r\n        }\r\n        S.innerHTML = html;\r\n        V.init(S.getElementsByTagName('a'));\r\n    }\r\n})\r\n```\r\n\r\n可以传空。此时表示该区域里面没有可获焦元素，常见场景为新闻类，此时该区域可以自动实现上下浏览的功能。\r\n\r\n该方法通常只需加载一次。\r\n\r\n### V.insertAfter(nodeList)\r\n\r\n向后追加子元素。常见场景为上拉加载，追加下一页等功能。\r\n\r\n```js\r\najax({\r\n    url:'XXX',\r\n    sunccess:function(data){\r\n        var div = document.createElement(\"div\");\r\n        var html = '';\r\n        for(var i=0;i<data.length;i++){\r\n            html+='<a>'+data[i]+'</a>';\r\n        }\r\n        div.innerHTML = html;\r\n        M.appendChild(div);\r\n        V.insertAfter(M.getElementsByTagName('a'));\r\n    }\r\n})\r\n```\r\n\r\n注意：追加元素时采用`M.appendChild(node)`方式，不要采用`M.inderHTML+=html`，因为\r\n\r\n```js\r\nM.inderHTML += html;\r\n\r\n//等效于\r\n\r\nM.inderHTML = M.inderHTML + html;\r\n```\r\n\r\n会清空原有元素的状态。\r\n\r\n### V.insertBefore(nodeList)\r\n\r\n与`insertAfter`相反，向前追加子元素。\r\n\r\n### V.onfocus()\r\n\r\n主动聚焦，当有多个区域时，可选择控制。(区域)\r\n\r\n```js\r\nvar V = new View(S);\r\nV.onfocus();\r\n```\r\n\r\n一个页面只有一个区域可以获焦，当一个区域获焦时，上一个区域会自动失去焦点。\r\n\r\n> 获焦的区域，容器会增加`focus`样式，通常在由子元素情况下，不会给容器增加额外样式，在没有子元素情况下，比如新闻浏览时，可以给容器加一个`focus`样式，以表示该区域正在获焦。\r\n\r\n**默认焦点**\r\n\r\n`autofocus`指定默认焦点，默认为该区域左上角的元素（有可能不是第`0`个，如绝对定位的情况）\r\n\r\n给元素指定`autofocus=true`可以在初始化自动聚焦到该焦点。(DOM)\r\n\r\n```html\r\n<div>\r\n    <a></a>\r\n    <a autofocus=\"true\"></a>\r\n    <a></a>\r\n    <a></a>\r\n</div>\r\n```\r\n\r\n### V.focusById(id)\r\n\r\n根据元素`id`聚焦，如果页面可滚动，则会自动定位到该元素。(元素)\r\n\r\n### V.focusByIndex(index)\r\n\r\n根据元素`index`聚焦，如果页面可滚动，则会自动定位到该元素。(元素)\r\n\r\n这里的`index`指的是元素在文档中相对于其他子元素的顺序。\r\n\r\n```html\r\n<div>\r\n    <a></a> <!--0-->\r\n    <div>\r\n        <span></span>\r\n        <a></a>  <!--1-->\r\n        <a></a>  <!--2-->\r\n    </div>\r\n    <a></a>  <!--3-->\r\n</div>\r\n```\r\n\r\n### V.findByDir(dir)\r\n\r\n根据方位查找元素，返回元素`index`，找不到会返回`null`。\r\n\r\n`dir`是一个表示方位的数组，可依次传入`left`、`right`、`up`、`down`\r\n\r\n```js\r\nV.findByDir['right','down','down'] //表示当前元素的右边的下边的下边，可累计\r\n```\r\n\r\n通常用于边界提前判断，预加载。\r\n\r\n例如，当下方还有两个元素（需要按两次“下”）的时候提前加载下一页。\r\n\r\n```js\r\nif(!this.findByDir['down','down']){\r\n    //...\r\n    this.down();\r\n    //...\r\n}\r\n```\r\n\r\n### V.sortby(arr)\r\n\r\n自定义按键移动规则。\r\n\r\n通常情况下会自动计算元素的上下左右关系，这是一个通用的计算方法，有些情况可能不尽人意，你可以通过该方法重新定义规则。\r\n\r\n需要在`V.init(nodeList)`之后调用。\r\n\r\n```js\r\nvar rules = [\r\n    [1,1,3,null],//第0个元素的位置关系\r\n    [null,2,3,0],\r\n    [1,null,3,1],\r\n    [1,2,null,0],\r\n]\r\nV.sortby(rules);\r\n```\r\n\r\n这个数组每一项表示每一个元素的位置关系，按照文档中的顺序（从0开始），比如第`0`个`[1,1,3,null]`，表示\r\n\r\n|方向|序列|说明|\r\n|---|---|---|\r\n|上|`1`|第1个元素|\r\n|右|`1`|第1个元素|\r\n|下|`3`|第3个元素|\r\n|左|`null`|没有元素|\r\n\r\n> 只有极少部分情况下（元素有重叠交叉情况，或者需要人为干预）会用到该功能\r\n\r\n### 回调\r\n\r\n这一部分是对按键的回调\r\n\r\n#### V.ok\r\n\r\n回车、确定。\r\n\r\n当按下确定时，会给当前获焦元素添加`pressIn`类，抬起时移除，可自定义按下效果。\r\n\r\n可以通过`V.isCurrent`来区分当前状态是否在点击同一个元素，优化体验。\r\n\r\n```js\r\nV.ok = function(item){\r\n    if(this.isCurrent){\r\n        console.log('重复点击了该元素');\r\n    }else{\r\n        console.log(item)//当前获焦元素的dom节点\r\n    }\r\n}\r\n```\r\n\r\n鼠标点击会触发该事件。\r\n\r\n#### V.left、V.right、V.up、V.down\r\n\r\n向左/右/上/下（处于边界时）。当获焦元素处于区域边界时触发。一般用于跨越区域。\r\n\r\n> 当处于边界时，如果没有指定触发回调，比如`V.left`，会给当前获焦元素添加`shake`类，这是一个抖动动画，300ms自动移除。（位于css/view.css）\r\n\r\n```js\r\nV.left = function(){\r\n    Vl.onfocus();//此时V会自动失去焦点，Vl会主动获焦\r\n}\r\n```\r\n\r\n#### V.back\r\n\r\n返回。当按返回键时触发。\r\n\r\n#### V.move\r\n\r\n移动时触发，回调参数为移动之前的元素，和移动之后的元素。\r\n\r\n```js\r\nV.move = function (prev, current) {\r\n    //prev移动之前\r\n    //current移动之前后\r\n}\r\n```\r\n\r\n鼠标点击会触发该事件。\r\n\r\n### 属性\r\n\r\n#### V.saveCurrent\r\n\r\n是否保留当前状态，类名为`current`。一般用作`tab`切换时跟随。默认为`false`。\r\n\r\n#### V.saveCurrentDelay\r\n\r\n是否保留当前状态，类名为`current`。一般用作`tab`切换时跟随，但是需要点击ok触发。默认为`false`。\r\n\r\n> 当重新回到该区域时，会自动定位到`current`位置。\r\n\r\n### V.scrollAnimate\r\n\r\n是否强制开启启动滚动动画（如果不支持会启用插件滚动）。默认为`true`。\r\n\r\n页面滚动是通过修改`scrollTop`和`scrollLeft`完成，如果你需要一个区域滚动，必须指明宽度或者高度，同时设置`overflow:hidden|auto`才能生效。\r\n\r\n如果需要动画，可以增加属性`scroll-behavior: smooth`（可能有兼容性问题，不影响功能）\r\n\r\n或者引入`smoothscroll.min.js`，设置`V.scrollAnimate = true`。\r\n\r\n\r\n### 指令\r\n\r\n类似于控制台，通过一些方法来模拟该区域实际的按键操作。\r\n\r\n#### V.onkey(action)\r\n\r\n*action*可选值`up`、`right`、`down`、`left`、`ok`、`back`，可主动调用该区域的按键操作。\r\n\r\n与真实的按键操作响应无异，包括该按键对应的回调事件。\r\n\r\n```js\r\nV.right = function () {\r\n    Vnav.onfocus();\r\n    Vnav.onkey('right');\r\n    Vnav.onkey('down');\r\n}\r\n```\r\n\r\n### 全局指令\r\n\r\n`moveLeft`、`moveUp`、`moveRight`、`moveDown`、`doConfirm`、`keyBack`\r\n\r\n该方法可以直接暴露给外部使用，从全局控制页面的焦点移动。\r\n\r\n通常适用于接管安卓的按键响应事件。\r\n\r\n```js\r\n//console\r\nmoveLeft();\r\nmoveUp();\r\n//...\r\n```\r\n\r\n### 鼠标操作\r\n\r\n现支持鼠标快速操作，可以同键盘无缝使用。\r\n\r\n点击鼠标左键可以触发元素的`ok`事件\r\n\r\n点击区域可以对区域进行聚焦。\r\n\r\n详细规则可以体验下面demo，与常规页面体验无异。\r\n\r\n> 注意：如果需要使用鼠标滚轮滚动，那么需要设置容器`overflow:auto`,而不能是`overflow:hidden`\r\n\r\n## 案例\r\n\r\n[https://web.codelabo.cn/auto-keyboard/](https://web.codelabo.cn/auto-keyboard/)\r\n\r\n**请使用键盘方向键上下左右体验，可以配合鼠标操作**\r\n\r\n> 可以查看源码，代码量很小，却有意想不到的效果。\r\n\r\n## 结语\r\n\r\n目前市面上并没有什么对键盘操作封装的库，键盘什么的这个方向确实比较窄，或者说比较冷门，希望能够帮助特定的人群吧。\r\n\r\n有这方面兴趣的欢迎交流，一起讨论。\r\n",
      "data": {
        "title": "javascript 键盘访问半自动化解决方案",
        "date": "2019-04-16 14:28:51",
        "tags": [
          "javascript",
          "keyborad"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/javascript-auto-keyboard.jpg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "## 概要\r\n\r\n这是一个半自动化的键盘访问解决方案，主要适用于需要完全键盘操作场景，比如大屏展示，电视，游戏菜单等，大大简化按键操作的逻辑。\r\n\r\n焦点使用虚拟焦点，也就是通过添加`.focus`等class实现，而不是原生自带的`:focus`，更利于定制化需求。\r\n\r\n基于`HTML`页面。\r\n\r\n> 比较冷门，键盘交互方向，不感兴趣的可以跳过。\r\n\r\n[项目地址](https://github.com/XboxYan/auto-keyboard)\r",
      "fileName": "javascript-auto-keyboard"
    },
    {
      "content": "这是关于的页面，可以在这里向世界介绍你！\r\n",
      "data": {
        "title": "关于",
        "date": "2019-01-25 19:09:48",
        "tags": null,
        "published": true,
        "hideInList": true,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "about"
    },
    {
      "content": "👏  欢迎使用 **Gridea** ！  \r\n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... \r\n\r\n<!-- more -->\r\n\r\n[Github](https://github.com/getgridea/gridea)  \r\n[Gridea 主页](http://hvenotes.fehey.com/)  \r\n[示例网站](http://fehey.com/)\r\n\r\n## 特性👇\r\n📝  你可以使用最酷的 **Markdown** 语法，进行快速创作  \r\n\r\n🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片  \r\n\r\n🏷️  你可以对文章进行标签分组  \r\n\r\n📋  你可以自定义菜单，甚至可以创建外部链接菜单  \r\n\r\n💻  你可以在 **𝖶𝗂𝗇𝖽𝗈𝗐𝗌** 或 **𝖬𝖺𝖼𝖮𝖲** 设备上使用此客户端  \r\n\r\n🌎  你可以使用 **𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌** 或 **Coding Pages** 向世界展示，未来将支持更多平台  \r\n\r\n💬  你可以进行简单的配置，接入 [Gitalk](https://github.com/gitalk/gitalk) 或 [DisqusJS](https://github.com/SukkaW/DisqusJS) 评论系统  \r\n\r\n🇬🇧  你可以使用**中文简体**或**英语**  \r\n\r\n🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力  \r\n\r\n🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步  \r\n\r\n🌱 当然 **Gridea** 还很年轻，有很多不足，但请相信，它会不停向前🏃\r\n\r\n未来，它一定会成为你离不开的伙伴\r\n\r\n尽情发挥你的才华吧！\r\n\r\n😘 Enjoy~\r\n",
      "data": {
        "title": "Hello Gridea",
        "date": "2018-12-12 00:00:00",
        "tags": [
          "Gridea"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/hello-gridea.png"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "👏  欢迎使用 **Gridea** ！  \r\n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... \r",
      "fileName": "hello-gridea"
    }
  ],
  "tags": [
    {
      "index": -1,
      "name": "css",
      "slug": "css",
      "used": true
    },
    {
      "index": -1,
      "name": "css3",
      "slug": "MmBXGBKG9",
      "used": true
    },
    {
      "index": -1,
      "name": "javascript",
      "slug": "javascript",
      "used": true
    },
    {
      "index": -1,
      "name": "keyborad",
      "slug": "keyborad",
      "used": true
    },
    {
      "name": "Gridea",
      "slug": "gridea",
      "used": true
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    },
    {
      "link": "/post/about",
      "name": "关于",
      "openType": "Internal"
    }
  ]
}