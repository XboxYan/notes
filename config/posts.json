{
  "posts": [
    {
      "content": "## 多级菜单\n\n在平时的项目中会经常碰到这样一种布局，暂且称之为多级菜单吧\n\n![](https://xboxyan.codelabo.cn/post-images/1558439549223.png)\n\n（截图来自于[ant-design](https://ant.design/components/menu-cn/)）\n\n这类布局也很容易，大概就是这样`ul`和`li`嵌套，如下\n\n```html\n<ul class=\"parent\">\n    <li>\n        <div>Navigation01</div>\n        <ul>\n            <li><div>Option01</div></li>\n            <li><div>Option02</div></li>\n            <li>\n                <div>Submenu</div>\n                <ul>\n                    <li><div>Option03</div></li>\n                    <li><div>Option04</div></li>\n                </ul>\n            </li>\n        </ul>\n    </li>\n    <li><div>Navigation02</div></li>\n</ul>\n```\n\n于是就得到下面一个很原始的样式。\n\n![](https://xboxyan.codelabo.cn/post-images/1558440703375.png)\n\n再经过简单的修饰就可以达到上面的效果了。\n\n当然，这个很容易，一般情况下我们是通过设置内边距来完成的，比如默认为\n\n```css\nul{\n\tpadding-left:40px;\n}\n```\n\n然后每一层级跟随父级逐步累积，然后就实现了，层级越深，距离左边的缩进越多的效果。\n\n## 多级菜单选中范围\n\n通过上面的布局和样式，很显然每一项的选择范围都是逐步缩进的，\n\n![](https://xboxyan.codelabo.cn/post-images/1558441705019.png)\n\n但是，可能设计师觉得不好看，往往会设计成通栏的形式，比如像上面[ant-design](https://ant.design/components/menu-cn/)的设计\n\n![](https://xboxyan.codelabo.cn/post-images/1558441856625.png)\n\n那么，该如何处理呢？\n\n## 通栏的处理方式\n\n首先，一个很自然的思路就是去除`ul`的`padding`，改为每一个子项分别指定`padding`\n\n```css\nul.parent{\n\tpadding: 0;\n}\n```\n\n然后将内边距直接写在`html`上，如下\n\n```html\n<ul  class=\"parent\">\n    <li>\n        <div style=\"padding-left:40px\">Navigation01</div>\n        <ul>\n            <li><div style=\"padding-left:80px\">Option01</div></li>\n            <li><div style=\"padding-left:80px\">Option02</div></li>\n            <li>\n                <div style=\"padding-left:80px\">Submenu</div>\n                <ul>\n                    <li><div style=\"padding-left:120px\">Option03</div></li>\n                    <li><div style=\"padding-left:120px\">Option04</div></li>\n                </ul>\n            </li>\n        </ul>\n    </li>\n    <li><div style=\"padding-left:40px\">Navigation02</div></li>\n</ul>\n```\n\n如果菜单层级较多，我们通常使用js来辅助生成，注意每一次循环来指定不同的内边距就可以了\n\n![](https://xboxyan.codelabo.cn/post-images/1558442384266.png)\n\n[ant-design](https://ant.design/components/menu-cn/)也是采取这种方式，可以自行打开控制台去查看。\n\n记得刚入前端的时候就是采取的这种方式，效果实现就好。\n\n不过，在现在看来，在`html`中使用内联样式始终不雅，而且数量较多时还需要和`js`扯上关系，能否优化一下呢\n\n下面列举两种css方式\n\n### 1.子选择器\n\n我们可以在上面的基础上，分别控制每一级的内边距，这里我们可以使用子选择器`>`\n\n```css\nul.parent>li>div{/**第一级**/\n    padding-left: 40px;\n}\nul.parent>li>ul>li>div{/**第二级**/\n    padding-left: 80px;\n}\nul.parent>li>ul>li>ul>li>div{/**第三级**/\n    padding-left: 120px;\n}\n/** ... **/\n```\n\n通常，在层级不是特别多的情况下，我们可以一一罗列出来，只需用选择器`ul>li`叠加即可，是不是比`style`方便维护了很多呢？\n\n### 2.absolute半依赖定位\n\n未完待续...\n\n\n\n",
      "data": {
        "title": "CSS 关于多级菜单的内边距的处理方式",
        "date": "2019-05-21 19:26:54",
        "tags": [
          "css"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "css-tree-padding"
    },
    {
      "content": "CSS3 中有很多表示元素序号的选择器，有以下几种\n\n`:first-child`、`:first-of-type`、`:last-of-type`、`:only-of-type`、`:only-child`、`:nth-child(n)`、`:nth-last-child(n)`、`:nth-of-type(n)`、`:nth-last-of-type(n)`、`:last-child`\n\n<!-- more -->\n\n初学者可能会比较容易混淆，这里我可以分一下类\n\n|***-of-type**|***-child**|\n|---|---|\n|`:first-of-type`|`:first-child`|\n|`:last-of-type`|`:last-child`|\n|`:nth-of-type(n)`|`:nth-child(n)`|\n|`:nth-last-of-type(n)`|`:nth-last-child(n)`|\n|`:only-of-type`|`:only-child`|\n\n可以看出完全是一一对应，相信CSS开发者都对这些选择器的功能有个大致印象，比如`first-*`表示第一个，`nth-*`表示第几个，`nth-last-*`表示倒数第几个...\n\n## *-of-type 和 *-child\n\n那么，***-of-type**和***-child** 到底有什么区别呢？\n\n从字面上来看，其实就是`type`和`child`的区别，也就是说\n\n**`type`表示类型，一类元素，比如都是`p`元素或者`div`元素**\n\n**`child`表示子元素，没有什么限制**\n\n这样描述可能不直观，下面列举一个实例来说明\n\n## :first-of-type 和 :first-child\n\n```html\n<div>\n\t<h1 class=\"h1\">标题1</h1>\n\t<h1  class=\"h2\">标题2</h1>\n\t<p class=\"p1\">段落1</p>\n\t<p class=\"p2\">段落2</p>\n</div>\n```\n\n这里写了一个交互实例，可以随时比较各个选择器的结果\n\n<p class=\"codepen\" data-height=\"622\" data-theme-id=\"34022\" data-default-tab=\"html,result\" data-user=\"xboxyan\" data-slug-hash=\"dEvxPr\" style=\"height: 622px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;\" data-pen-title=\"css3 选择器:first-of-type 和:first-child\">\n  <span>See the Pen <a href=\"https://codepen.io/xboxyan/pen/dEvxPr/\">\n  css3 选择器:first-of-type 和:first-child</a> by XboxYan (<a href=\"https://codepen.io/xboxyan\">@xboxyan</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.</span>\n</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n下面是各种选择的结果\n\n1. `div :first-of-type`可以选中 *标题1* 和 *段落1*\n\n1. `div h1:first-of-type`可以选中 *标题1*\n\n1. `div p:first-of-type`可以选中 *段落1*\n\n1. `div .h1:first-of-type` 可以选中 *标题1*\n\n1. `div .h2:first-of-type` 未匹配\n\n1. `div :first-child` 可以选中 *标题1*\n\n1. `div p:first-child` 未匹配\n\n1. `div h1:first-child`  `可以选中 *标题1*\n\n1. `div .h1:first-child`  `可以选中 *标题1*\n\n1. `div .h2:first-child`  未匹配\n\n这里有个容易出错的地方，比如`div .h2:first-of-type`，很多人以为会选择到第一个class为`.h2`的元素，其实不是的，这里可以这么来理解：\n\n**首先，`div .h2:first-of-type`会查找`.h2`类名所对应的元素，这里是`h1`元素，所以`:first-of-type`会匹配第一个`h1`元素，也就是说，这里的class类名只是找到对应元素类型的作用。接下来结合起来看，第一个`h1`的元素的class并不是`.h2`，所以就无法匹配到。**\n\n**同样，`div p:first-child`也是同样的道理，`:first-child`会首先找第一个元素，然后发现第一个元素并不是`p`元素，所以也匹配不到**\n\n由此可见，我们在用`:first-of-type`时，其实只需要带上标签名就可以了，比如`div p:first-of-type`，根本不需要带上类名，如果不加标签名，那么会选择每种类型元素的第一个（示例1）\n\n而用`:first-child`时，根本不需要带上任何标识，因为始终会匹配到第一个元素，否则加上别的条件就匹配不到了（当然特殊需求除外）。\n\n那么，如果想实现上述第一个`.h2`该如何实现呢，很可惜，这些方式不能满足，你只能通过其他方式来完成，比如`~`选择器\n\n```html\n<div>\n\t<h1 class=\"h1\">标题1</h1>\n\t<h1  class=\"h2\">标题2</h1>\n\t<h1  class=\"h2\">标题2</h1>\n\t<p class=\"p1\">段落1</p>\n\t<p class=\"p2\">段落2</p>\n</div>\n```\n\n这种情况下，如何选择到第一个`h1.h2`呢?\n\n---\n\n思考一下...\n\n---\n\n直接给答案\n\n```css\n.h2{ \n  outline:2px solid red;\n}\n.h2~.h2{\n  outline:0;\n}\n```\n\n意思就是先选中所有的`.h2`，然后排除掉兄弟节点的其他`.h2`\n\n<p class=\"codepen\" data-height=\"379\" data-theme-id=\"34022\" data-default-tab=\"html,result\" data-user=\"xboxyan\" data-slug-hash=\"GamPQJ\" style=\"height: 379px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;\" data-pen-title=\"css 选择器\">\n  <span>See the Pen <a href=\"https://codepen.io/xboxyan/pen/GamPQJ/\">\n  css 选择器</a> by XboxYan (<a href=\"https://codepen.io/xboxyan\">@xboxyan</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.</span>\n</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n理解上面几种选择器的规则，那么下面几类都是一样的了\n\n## :last-of-type和:last-child\n\n这与`:first-of-type` 和 `:first-child`用法完全一致，表示最后一个，这里不做多讲解\n\n有一点注意的是，`:first-child`是CSS2的范畴，意味着在IE8也能使用，而`last-child`是CSS3的规范，在同时都能满足需求时，如果需要更好的兼容性，建议使用`:first-child`。\n\n一个很常见的场景，比如一个列表，列表的每一项都一条分割线，我们可以使用`border`来模拟，那么是上边框还是下边框呢，都可以满足需求\n\n```css\nli{\n\t***\n\tborder-top:1px solid;\n}\nli:first-child{\n\tborder-top:0;\n}\n```\n\n显然，使用上边框结合`:first-child`兼容性更好。\n\n## :nth-of-type(n)和:nth-child(n)\n\n这类选择器主要是选择第n个元素，跟元素序号有关，注意这里的起始序号为1（和js略微不同）\n\n`n`可以是数字、关键词或公式。\n\n比如说`p:nth-of-type(1)`表示每个父级下第一个`p`元素，等同于`p:first-of-type`\n\n关键词可以选择`odd`和`even`，分别表示奇数和偶数，常见场景就是表格\n\n```css\ntr:nth-child(odd){\n\tbackground:#ff0000;\n}\ntr:nth-child(even){\n\tbackground:#0000ff;\n}\n```\n\n`n`还可以使用公式`an + b`，常见场景是选择周期性的元素\n\n```css\np:nth-child(3n+0){\n\tbackground:#ff0000;\n}\n```\n\n## `:nth-last-of-type(n)`和`:nth-last-child(n)`\n\n与`:nth-of-type(n)`和`:nth-child(n)`基本一致，只是从后面开始计数\n\n结合`:nth-last-child(n)`与`:first-child`可以匹配出列表中不同元素数量的不同样式\n\n比如`:nth-last-child(3):first-child`表示从后往前数选中第3个子元素，同时也是第一个元素，那么就可以判断改列表中共有3个元素，结合兄弟选择器`+`和`~`可以对不同数量的子元素分别指定样式\n\n```css\nli:only-child {\n  height: 100%;\n}\n/* 2个 */\nli:first-child:nth-last-child(2),\nli:first-child:nth-last-child(2) + li {\n  width: 50%; height: 50%;\n}\nli:first-child:nth-last-child(2) + li {\n  margin-left: auto;\n}\n/* 3个 */\nli:first-child:nth-last-child(3),\nli:first-child:nth-last-child(3) ~ li {\n  width: 50%; height: 50%;\n}\n```\n\n大家可以看看[张鑫旭的这篇文章](https://www.zhangxinxu.com/wordpress/2019/03/nth-last-child-css-layout/)，算是一个比较实用的场景\n\n## `:only-of-type 和 :only-child`\n\n这个是表示当只有一个元素，或者同类型元素只有一个的时候使用\n\n```html\n<div>\n\t<h1 class=\"h1\">标题1</h1>\n\t<h1  class=\"h2\">标题2</h1>\n\t<h1  class=\"h2\">标题2</h1>\n\t<p class=\"p1\">段落1</p>\n\t<span>文本</span>\n</div>\n```\n\n* `div :only-of-type`可以选中 *标题2* *文本*\n* `div p:only-of-type`可以选中 *标题2*\n* `div :only-child` 匹配不到任何元素\n\n## 小节\n\n其实大家只要注意 **`*-of-type` 是选择相同类型的元素 、` *-child`是选择子节点 ** 就好了，\n\n相信未来可能会出现更全面的选择器，比如`nth-of-class`（根据class来选择），`nth-of-*` （根据任意选择器来选择），还是期待一下吧~\n\n\n\n",
      "data": {
        "title": "CSS3 中关于 *-of-type 和 *-child的差异性及适用场景",
        "date": "2019-05-16 18:58:39",
        "tags": [
          "css3"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/css3-of-type-child.jpg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "CSS3 中有很多表示元素序号的选择器，有以下几种\n\n`:first-child`、`:first-of-type`、`:last-of-type`、`:only-of-type`、`:only-child`、`:nth-child(n)`、`:nth-last-child(n)`、`:nth-of-type(n)`、`:nth-last-of-type(n)`、`:last-child`",
      "fileName": "css3-of-type-child"
    },
    {
      "content": "css3中实现动画一般有两种方式，一个是`transition`过渡，一个是`animation`动画。最主要区别就是`transition`需要条件触发，通常会用`hover`来触发，而`animation`则更灵活，可以自动播放，也可以通过条件触发。\n\n<!-- more -->\n\n那么，如何实现一个元素出现动画呢？\n\n如果是`transition`，可以很轻松的实现这一效果，例如\n\n```css\n.box{\n  visibility:hidden;\n  opacity:0;\n  transform:translateY(100px);\n  transition:.3s;\n}\n.show{\n  visibility:visible;\n  opacity:1;\n  transform:translateY(0);\n}\n```\n\n这样就实现了一个“从下至上，透明度从0至1”的出现动画，很常用不是吗。\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"show-transition\" src=\"//codepen.io/xboxyan/embed/LveVoO/?height=300&theme-id=34022&default-tab=css,result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/xboxyan/pen/LveVoO/'>show-transition</a> by XboxYan\n  (<a href='https://codepen.io/xboxyan'>@xboxyan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n\n当然，我们也可以用`animation`来实现，\n\n```css\n.box{\n  visibility:hidden;\n  opacity:0;\n  transform:translateY(100px);\n  transition:.3s;\n}\n.show{\n  animation:show .5s forwards;\n}\n\n.hide{\n  visibility:visible;\n  opacity: 1;\n  transform: translateY(0);\n  animation:hide .5s forwards;\n}\n@keyframes show{\n  to {\n    visibility:visible;\n    opacity: 1;\n    transform: translateY(0)\n  }\n}\n@keyframes hide{\n  to {\n    visibility:hidden;\n    opacity: 0;\n    transform: translateY(100px)\n  }\n}\n```\n\n我的天，居然要写这么多，才能实现和上面一样的效果，没办法，出现和消失是两组不同的动画，所以需要定义两个动画。\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"show-animation\" src=\"//codepen.io/xboxyan/embed/KYZdKp/?height=300&theme-id=34022&default-tab=css,result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/xboxyan/pen/KYZdKp/'>show-animation</a> by XboxYan\n  (<a href='https://codepen.io/xboxyan'>@xboxyan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n\n## 元素出现动画\n\n上面简单的介绍了动画的两种实现方法。严格来讲，`transition`只是过渡，只是切换样式过程中有动画的效果，而`animation`才是真正做动画的。当然也需要根据自己的实际需求来选择。\n\n下面来看这样一个需求：\n\n通常页面上要全局显示一个消息提示，类似于`toast`效果。这是我通常的做法\n\n```js\nfunction showMessage(txt){\n    this.timer && clearTimeout(this.timer);\n    var oDiv = document.getElementById('messageInfo');\n    if(!oDiv){\n      oDiv = document.createElement('div');\n      oDiv.className = 'messageInfo';\n      oDiv.id = 'messageInfo';\n      document.body.appendChild(oDiv);\n    }\n    oDiv.innerHTML = '<span>'+txt+'</span>';\n    oDiv.classList.add('show');\n    this.timer = setTimeout(function(){\n      oDiv.classList.remove('show');\n    },2000)\n}\n```\n\n原理就是，向页面添加一个`div#messageInfo`容器，然后添加类名`.show`让元素出现，2s后自动移除`.show`实现隐藏，效果如下\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"toast\" src=\"//codepen.io/xboxyan/embed/axEddQ/?height=300&theme-id=34022&default-tab=js,result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/xboxyan/pen/axEddQ/'>toast</a> by XboxYan\n  (<a href='https://codepen.io/xboxyan'>@xboxyan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n\n可以很明显的看到一个效果就是，第一次出现的时候是没有动画的，以后就正常了。可能平时项目中，这一点小瑕疵也没什么影响，毕竟很大一部分人连动画都不给啊，直接就是`display:none`和`display:block`，可以说是提不上体验了。\n\n那么，为什么会出现这种现象呢？\n\n首先明白一点，`transition`是不会自动触发的，上面是通过添加和移除类名来实现过渡效果的。但是在第一次元素刚刚创建的时候，此时页面改元素还未加载完成，这个时候立即添加类名，其实是可以等同于是一起创建的，没有形成过渡效果。解决这个问题很简单，就是稍微延时一下\n\n```js\n//...\nsetTimeout(function(){\n   oDiv.classList.add('show');\n},50)\n//...\n```\n\n这样就基本上解决了这个问题，如下\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"toast-fix\" src=\"//codepen.io/xboxyan/embed/LveNYN/?height=300&theme-id=34022&default-tab=js,result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/xboxyan/pen/LveNYN/'>toast-fix</a> by XboxYan\n  (<a href='https://codepen.io/xboxyan'>@xboxyan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n\n但是，理论上这里的延迟越小越好，我测试了一下，大概和浏览器的性能有关吧，用定时器的目的也仅仅是等待元素加载完成，而dom也没有原生监听加载完成事件，所以只能用定时器估一个大概的值。\n\n但是，这仍然是一个瑕疵，从代码结构上来讲，这也是无法忍受的。那么，还有没有更好的方法呢？答案就是`animation`\n\n## Animation\n\n虽然从开头的例子来看，`animation`的写法又臭又长，但是也正体现出它的功能强大，其中之一就是自动播放动画\n\n那么，把上面的`toast`改造一下\n\n```css\n.messageInfo{ \n    /**...**/\n    animation:show .5s forwards;\n}\n.hide{\n  visibility:visible;\n  opacity: 1;\n  transform: translateY(0);\n  animation:hide .5s forwards;\n}\n@keyframes show{\n  to {\n    visibility:visible;\n    opacity: 1;\n    transform: translateY(0)\n  }\n}\n@keyframes hide{\n  to {\n    visibility:hidden;\n    opacity: 0;\n    transform: translateY(-100%)\n  }\n}\n```\n\njs基本和之前一致\n\n```js\nfunction showMessage(txt){\n    this.timer && clearTimeout(this.timer);\n    var oDiv = document.getElementById('messageInfo');\n    if(!oDiv){\n      oDiv = document.createElement('div');\n      oDiv.className = 'messageInfo';\n      oDiv.id = 'messageInfo';\n      document.body.appendChild(oDiv);\n    }\n    oDiv.innerHTML = '<span>'+txt+'</span>';\n    oDiv.classList.remove('hide');//默认是显示\n    this.timer = \n      setTimeout(function(){\n      oDiv.classList.add('hide');//2s后隐藏\n    },2000)\n}\n```\n\n效果如下\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"toast-animation\" src=\"//codepen.io/xboxyan/embed/yrpOPm/?height=300&theme-id=34022&default-tab=css,result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/xboxyan/pen/yrpOPm/'>toast-animation</a> by XboxYan\n  (<a href='https://codepen.io/xboxyan'>@xboxyan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n\n可以说非常完美了。\n\n## 其他应用场景\n\n元素添加动画\n\n通常在添加表单或者上传图片时，如果需要让新添加的元素产生一个动画效果，那么可以用到`animation`\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"css 元素出现动画\" src=\"//codepen.io/xboxyan/embed/axLPgN/?height=300&theme-id=34022&default-tab=css,result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/xboxyan/pen/axLPgN/'>css 元素出现动画</a> by XboxYan\n  (<a href='https://codepen.io/xboxyan'>@xboxyan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n\n当然，还可以做到分页加载动画，需要给每个元素添加一个延时`animation-delay`即可\n\n```css\n/*animation-delay*/\n.list li:not(.hide):nth-child(5n + 1) {\n    animation-delay: .3s;\n}\n.list li:not(.hide):nth-child(5n + 2) {\n    animation-delay: .6s;\n}\n.list li:not(.hide):nth-child(5n + 3) {\n    animation-delay: .9s;\n}\n.list li:not(.hide):nth-child(5n + 4) {\n    animation-delay: 1.2s;\n}\n.list li:not(.hide):nth-child(5n + 5) {\n    animation-delay: 1.5s;\n}\n```\n\n效果如下，元素会依次登场，预览窗口比较小，建议在[原链接](https://codepen.io/xboxyan/pen/dLVwLv)查看\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"css批量出现动画\" src=\"//codepen.io/xboxyan/embed/dLVwLv/?height=300&theme-id=34022&default-tab=css,result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/xboxyan/pen/dLVwLv/'>css批量出现动画</a> by XboxYan\n  (<a href='https://codepen.io/xboxyan'>@xboxyan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n\n然后，还可以实现九宫格动画，让元素在出现的时候从左上方依次向右下方扩散，同样是用到了`animation-delay`\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"css九宫格出现动画\" src=\"//codepen.io/xboxyan/embed/zXEyLY/?height=300&theme-id=34022&default-tab=css,result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/xboxyan/pen/zXEyLY/'>css九宫格出现动画</a> by XboxYan\n  (<a href='https://codepen.io/xboxyan'>@xboxyan</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n\n很酷炫不是吗，无需用到js，也无需用到其它框架，纯天然，支持的浏览器体验更上一层楼，不支持的浏览器也无伤大雅\n\n## 小节\n\n总体来说，`animation`远比`transition`要强大的多，当然在实际使用中，如果有交互，如鼠标移入，首先看`transition`能否实现，其次才是`animation`，如果像这一类元素出现（生成）动画，那么就需要使用到`animation`了。\n\n\n\n\n\n",
      "data": {
        "title": "CSS3 元素出现动画实例",
        "date": "2019-04-16 21:15:05",
        "tags": [
          "css3"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/css3-appear-animation.jpg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "css3中实现动画一般有两种方式，一个是`transition`过渡，一个是`animation`动画。最主要区别就是`transition`需要条件触发，通常会用`hover`来触发，而`animation`则更灵活，可以自动播放，也可以通过条件触发。",
      "fileName": "css3-appear-animation"
    },
    {
      "content": "## 概要\n\n这是一个半自动化的键盘访问解决方案，主要适用于需要完全键盘操作场景，比如大屏展示，电视，游戏菜单等，大大简化按键操作的逻辑。\n\n焦点使用虚拟焦点，也就是通过添加`.focus`等class实现，而不是原生自带的`:focus`，更利于定制化需求。\n\n基于`HTML`页面。\n\n> 比较冷门，键盘交互方向，不感兴趣的可以跳过。\n\n[项目地址](https://github.com/XboxYan/auto-keyboard)\n\n <!-- more -->\n\n## 特点\n\n模块化编程方式\n\n统一的按键处理\n\n统一的滚动动画\n\n[马上体验](https://web.codelabo.cn/auto-keyboard/)\n\n## 快速入门\n\n由于实际场景复杂多样，过于全反而会让业务代码更繁杂，不可维护。\n\n该功能插件仅针对于局部实现自动化操作，整体页面布局仍需开发者手动协调。\n\n具体是指开发者需要手动讲页面分为几块逻辑区域，比如下方的键盘区和搜索列表区。\n\n然后对每块区域分别调用`new View()`，每一块区域的逻辑互不干扰，可独立开发。\n\n```html\n<link href=\"./css/view.css\" type=\"text/css\" rel=\"stylesheet\">\n<div class=\"search_keyborad\" id=\"search\">\n    <a data-key=\"A\">A</a>\n    <a data-key=\"B\">B</a>\n    <a data-key=\"B\">C</a>\n    ...\n</div>\n<ul class=\"search_list\" id=\"list\">\n    <li class=\"search_item\">\n        <img src=\"\" >\n        <h3>11人类DNA密码破译</h3>\n    </li>\n    <li class=\"search_item\">\n        <img src=\"\" >\n        <h3>22人类DNA密码破译</h3>\n    </li>\n    ...\n</ul>\n<script type=\"text/javascript\" src=\"./js/smoothscroll.min.js\"></script>\n<script type=\"text/javascript\" src=\"./js/view.js\"></script>\n```\n\n```js\nvar S = $('search');\t\nvar L = $('list');\nvar V = new View(S);\nvar Vl = new View(L);\nV.init(S.getElementsByTagName('a'));\nVl.init(L.getElementsByTagName('li'));\nV.onfocus();\n```\n\n这样，每块区域的按键都已经自动适配了。\n\n然后针对每块区域的关联适当写一些逻辑即可。\n\n## 概念\n\n**区域** 指一块包含可获焦同类型同功能一类元素的集合，通过 `new View(container)`创建。\n\n**元素** 指区域里面每一个可以获焦的节点。\n\n## API\n\n通过`new View(#container)`适配的区域，可获焦元素可以是常见的`n*m`分布，也可以是绝对定位的任意布局。\n\n通过`V.init(children)`来初始化可获焦子元素，传入`nodeList`即可，与页面层级无关。\n\n### new View(container)\n\n核心方法。创建一个区域，传入参数为页面的一个容器。\n\n```js\nvar con = document.getElemetById('con');\nvar V = new View(con);\n```\n\n如果不传`container`，可创建一个虚拟的区域，你可以进入该区域进行其他操作，比如悬浮窗，视频播放等等。\n\n该方法通常只需加载一次。\n\n### V.init(nodeList)\n\n初始化，传入参数为需要获焦的子元素，通常使用`getElementsByTagName`来一次性传入多个。\n\n也可以通过数组形式传入特定的子元素，如下。\n\n```js\nvar child = [ nodeA,nodeB,nodeC ];\nV.init(child)\n```\n\n目的是能够完全控制子元素，因为有些情况下子元素可能不在同一层级。比如下方的`a`元素\n\n```html\n<div id=\"con\">\n    <a></a>\n    <div>\n        <span></span>\n        <a></a>\n        <a></a>\n    </div>\n    <a></a>\n</div>\n```\n\n该方法需要等待页面加载完全后使用（需要获取元素的位置关系），也就是说当动态加载网络数据时，需等待只元素加入容器之后调用\n\n```js\nV.init(S.getElementsByTagName('a'));\n\n//动态数据\najax({\n    url:'XXX',\n    sunccess:function(data){\n        var html = '';\n        for(var i=0;i<data.length;i++){\n            html+='<a>'+data[i]+'</a>';\n        }\n        S.innerHTML = html;\n        V.init(S.getElementsByTagName('a'));\n    }\n})\n```\n\n可以传空。此时表示该区域里面没有可获焦元素，常见场景为新闻类，此时该区域可以自动实现上下浏览的功能。\n\n该方法通常只需加载一次。\n\n### V.insertAfter(nodeList)\n\n向后追加子元素。常见场景为上拉加载，追加下一页等功能。\n\n```js\najax({\n    url:'XXX',\n    sunccess:function(data){\n        var div = document.createElement(\"div\");\n        var html = '';\n        for(var i=0;i<data.length;i++){\n            html+='<a>'+data[i]+'</a>';\n        }\n        div.innerHTML = html;\n        M.appendChild(div);\n        V.insertAfter(M.getElementsByTagName('a'));\n    }\n})\n```\n\n注意：追加元素时采用`M.appendChild(node)`方式，不要采用`M.inderHTML+=html`，因为\n\n```js\nM.inderHTML += html;\n\n//等效于\n\nM.inderHTML = M.inderHTML + html;\n```\n\n会清空原有元素的状态。\n\n### V.insertBefore(nodeList)\n\n与`insertAfter`相反，向前追加子元素。\n\n### V.onfocus()\n\n主动聚焦，当有多个区域时，可选择控制。(区域)\n\n```js\nvar V = new View(S);\nV.onfocus();\n```\n\n一个页面只有一个区域可以获焦，当一个区域获焦时，上一个区域会自动失去焦点。\n\n> 获焦的区域，容器会增加`focus`样式，通常在由子元素情况下，不会给容器增加额外样式，在没有子元素情况下，比如新闻浏览时，可以给容器加一个`focus`样式，以表示该区域正在获焦。\n\n**默认焦点**\n\n`autofocus`指定默认焦点，默认为该区域左上角的元素（有可能不是第`0`个，如绝对定位的情况）\n\n给元素指定`autofocus=true`可以在初始化自动聚焦到该焦点。(DOM)\n\n```html\n<div>\n    <a></a>\n    <a autofocus=\"true\"></a>\n    <a></a>\n    <a></a>\n</div>\n```\n\n### V.focusById(id)\n\n根据元素`id`聚焦，如果页面可滚动，则会自动定位到该元素。(元素)\n\n### V.focusByIndex(index)\n\n根据元素`index`聚焦，如果页面可滚动，则会自动定位到该元素。(元素)\n\n这里的`index`指的是元素在文档中相对于其他子元素的顺序。\n\n```html\n<div>\n    <a></a> <!--0-->\n    <div>\n        <span></span>\n        <a></a>  <!--1-->\n        <a></a>  <!--2-->\n    </div>\n    <a></a>  <!--3-->\n</div>\n```\n\n### V.findByDir(dir)\n\n根据方位查找元素，返回元素`index`，找不到会返回`null`。\n\n`dir`是一个表示方位的数组，可依次传入`left`、`right`、`up`、`down`\n\n```js\nV.findByDir['right','down','down'] //表示当前元素的右边的下边的下边，可累计\n```\n\n通常用于边界提前判断，预加载。\n\n例如，当下方还有两个元素（需要按两次“下”）的时候提前加载下一页。\n\n```js\nif(!this.findByDir['down','down']){\n    //...\n    this.down();\n    //...\n}\n```\n\n### V.sortby(arr)\n\n自定义按键移动规则。\n\n通常情况下会自动计算元素的上下左右关系，这是一个通用的计算方法，有些情况可能不尽人意，你可以通过该方法重新定义规则。\n\n需要在`V.init(nodeList)`之后调用。\n\n```js\nvar rules = [\n    [1,1,3,null],//第0个元素的位置关系\n    [null,2,3,0],\n    [1,null,3,1],\n    [1,2,null,0],\n]\nV.sortby(rules);\n```\n\n这个数组每一项表示每一个元素的位置关系，按照文档中的顺序（从0开始），比如第`0`个`[1,1,3,null]`，表示\n\n|方向|序列|说明|\n|---|---|---|\n|上|`1`|第1个元素|\n|右|`1`|第1个元素|\n|下|`3`|第3个元素|\n|左|`null`|没有元素|\n\n> 只有极少部分情况下（元素有重叠交叉情况，或者需要人为干预）会用到该功能\n\n### 回调\n\n这一部分是对按键的回调\n\n#### V.ok\n\n回车、确定。\n\n当按下确定时，会给当前获焦元素添加`pressIn`类，抬起时移除，可自定义按下效果。\n\n可以通过`V.isCurrent`来区分当前状态是否在点击同一个元素，优化体验。\n\n```js\nV.ok = function(item){\n    if(this.isCurrent){\n        console.log('重复点击了该元素');\n    }else{\n        console.log(item)//当前获焦元素的dom节点\n    }\n}\n```\n\n鼠标点击会触发该事件。\n\n#### V.left、V.right、V.up、V.down\n\n向左/右/上/下（处于边界时）。当获焦元素处于区域边界时触发。一般用于跨越区域。\n\n> 当处于边界时，如果没有指定触发回调，比如`V.left`，会给当前获焦元素添加`shake`类，这是一个抖动动画，300ms自动移除。（位于css/view.css）\n\n```js\nV.left = function(){\n    Vl.onfocus();//此时V会自动失去焦点，Vl会主动获焦\n}\n```\n\n#### V.back\n\n返回。当按返回键时触发。\n\n#### V.move\n\n移动时触发，回调参数为移动之前的元素，和移动之后的元素。\n\n```js\nV.move = function (prev, current) {\n    //prev移动之前\n    //current移动之前后\n}\n```\n\n鼠标点击会触发该事件。\n\n### 属性\n\n#### V.saveCurrent\n\n是否保留当前状态，类名为`current`。一般用作`tab`切换时跟随。默认为`false`。\n\n#### V.saveCurrentDelay\n\n是否保留当前状态，类名为`current`。一般用作`tab`切换时跟随，但是需要点击ok触发。默认为`false`。\n\n> 当重新回到该区域时，会自动定位到`current`位置。\n\n### V.scrollAnimate\n\n是否强制开启启动滚动动画（如果不支持会启用插件滚动）。默认为`true`。\n\n页面滚动是通过修改`scrollTop`和`scrollLeft`完成，如果你需要一个区域滚动，必须指明宽度或者高度，同时设置`overflow:hidden|auto`才能生效。\n\n如果需要动画，可以增加属性`scroll-behavior: smooth`（可能有兼容性问题，不影响功能）\n\n或者引入`smoothscroll.min.js`，设置`V.scrollAnimate = true`。\n\n\n### 指令\n\n类似于控制台，通过一些方法来模拟该区域实际的按键操作。\n\n#### V.onkey(action)\n\n*action*可选值`up`、`right`、`down`、`left`、`ok`、`back`，可主动调用该区域的按键操作。\n\n与真实的按键操作响应无异，包括该按键对应的回调事件。\n\n```js\nV.right = function () {\n    Vnav.onfocus();\n    Vnav.onkey('right');\n    Vnav.onkey('down');\n}\n```\n\n### 全局指令\n\n`moveLeft`、`moveUp`、`moveRight`、`moveDown`、`doConfirm`、`keyBack`\n\n该方法可以直接暴露给外部使用，从全局控制页面的焦点移动。\n\n通常适用于接管安卓的按键响应事件。\n\n```js\n//console\nmoveLeft();\nmoveUp();\n//...\n```\n\n### 鼠标操作\n\n现支持鼠标快速操作，可以同键盘无缝使用。\n\n点击鼠标左键可以触发元素的`ok`事件\n\n点击区域可以对区域进行聚焦。\n\n详细规则可以体验下面demo，与常规页面体验无异。\n\n> 注意：如果需要使用鼠标滚轮滚动，那么需要设置容器`overflow:auto`,而不能是`overflow:hidden`\n\n## 案例\n\n[https://web.codelabo.cn/auto-keyboard/](https://web.codelabo.cn/auto-keyboard/)\n\n**请使用键盘方向键上下左右体验，可以配合鼠标操作**\n\n> 可以查看源码，代码量很小，却有意想不到的效果。\n\n## 结语\n\n目前市面上并没有什么对键盘操作封装的库，键盘什么的这个方向确实比较窄，或者说比较冷门，希望能够帮助特定的人群吧。\n\n有这方面兴趣的欢迎交流，一起讨论。\n",
      "data": {
        "title": "javascript 键盘访问半自动化解决方案",
        "date": "2019-04-16 14:28:51",
        "tags": [
          "javascript",
          "keyborad"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/javascript-auto-keyboard.jpg"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "## 概要\n\n这是一个半自动化的键盘访问解决方案，主要适用于需要完全键盘操作场景，比如大屏展示，电视，游戏菜单等，大大简化按键操作的逻辑。\n\n焦点使用虚拟焦点，也就是通过添加`.focus`等class实现，而不是原生自带的`:focus`，更利于定制化需求。\n\n基于`HTML`页面。\n\n> 比较冷门，键盘交互方向，不感兴趣的可以跳过。\n\n[项目地址](https://github.com/XboxYan/auto-keyboard)",
      "fileName": "javascript-auto-keyboard"
    },
    {
      "content": "这是关于的页面，可以在这里向世界介绍你！\r\n",
      "data": {
        "title": "关于",
        "date": "2019-01-25 19:09:48",
        "tags": null,
        "published": true,
        "hideInList": true,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "about"
    },
    {
      "content": "👏  欢迎使用 **Gridea** ！  \r\n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... \r\n\r\n<!-- more -->\r\n\r\n[Github](https://github.com/getgridea/gridea)  \r\n[Gridea 主页](http://hvenotes.fehey.com/)  \r\n[示例网站](http://fehey.com/)\r\n\r\n## 特性👇\r\n📝  你可以使用最酷的 **Markdown** 语法，进行快速创作  \r\n\r\n🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片  \r\n\r\n🏷️  你可以对文章进行标签分组  \r\n\r\n📋  你可以自定义菜单，甚至可以创建外部链接菜单  \r\n\r\n💻  你可以在 **𝖶𝗂𝗇𝖽𝗈𝗐𝗌** 或 **𝖬𝖺𝖼𝖮𝖲** 设备上使用此客户端  \r\n\r\n🌎  你可以使用 **𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌** 或 **Coding Pages** 向世界展示，未来将支持更多平台  \r\n\r\n💬  你可以进行简单的配置，接入 [Gitalk](https://github.com/gitalk/gitalk) 或 [DisqusJS](https://github.com/SukkaW/DisqusJS) 评论系统  \r\n\r\n🇬🇧  你可以使用**中文简体**或**英语**  \r\n\r\n🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力  \r\n\r\n🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步  \r\n\r\n🌱 当然 **Gridea** 还很年轻，有很多不足，但请相信，它会不停向前🏃\r\n\r\n未来，它一定会成为你离不开的伙伴\r\n\r\n尽情发挥你的才华吧！\r\n\r\n😘 Enjoy~\r\n",
      "data": {
        "title": "Hello Gridea",
        "date": "2018-12-12 00:00:00",
        "tags": [
          "Gridea"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/hello-gridea.png"
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "👏  欢迎使用 **Gridea** ！  \r\n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... \r",
      "fileName": "hello-gridea"
    }
  ],
  "tags": [
    {
      "index": -1,
      "name": "css",
      "slug": "css",
      "used": true
    },
    {
      "index": -1,
      "name": "css3",
      "slug": "MmBXGBKG9",
      "used": true
    },
    {
      "index": -1,
      "name": "javascript",
      "slug": "javascript",
      "used": true
    },
    {
      "index": -1,
      "name": "keyborad",
      "slug": "keyborad",
      "used": true
    },
    {
      "name": "Gridea",
      "slug": "gridea",
      "used": true
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    },
    {
      "link": "/post/about",
      "name": "关于",
      "openType": "Internal"
    }
  ]
}